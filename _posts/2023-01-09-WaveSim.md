---
layout: post
title: "Water Wave Simulation"
description: "Water wave animation and simulation using FFTs."
date: 2023-01-09
permalink: WaterWaves
---

<script src="js/lifft.js" /></script>

<script>'use strict';
const WIDGETS = [];

let VISIBILITY = new IntersectionObserver(function(list){
	for(let e of list) e.target.widget.visible = e.intersectionRatio > 0;
})

class Widget {
	constructor(canvas_id, body){
		const canvas = this.canvas = document.getElementById(canvas_id);
		canvas.width = canvas.parentElement.clientWidth;
		this.ctx = canvas.getContext("2d");
		
		this.repaint = body(this);
		this.visible = false;
		WIDGETS.push(this);
		
		canvas.onmouseenter = (e => {
			this.mfocus = true;
			this.mprev = this.mpos = {x: e.offsetX, y: e.offsetY};
		})
		canvas.onmouseleave = (e => this.mfocus = this.mleft = this.mright = false);
		canvas.onmousemove = (e => this.mpos = {x: e.offsetX, y: e.offsetY});
		canvas.onmouseup = canvas.onmousedown = (e => {
			this.mleft = ((e.buttons & 1) != 0);
			this.mright = ((e.buttons & 2) != 0);
		})
		canvas.oncontextmenu = (e => false);
		
		this.mfocus = false;
		this.mpos = {x: 0, y: 0};
		this.mprev = {x: 0, y: 0};
		
		canvas.widget = this;
		VISIBILITY.observe(canvas);
	}
	
	get mlocal(){
		const {x, y} = this.mpos;
		const m = this.ctx.getTransform().inverse();
		return {x:x*m.a + y*m.c + m.e, y:x*m.b + y*m.d + m.f};
	}
}

let TIME = 0;
function ANIMATE(ms){
	const time = 1e-3*ms;
	const dt = (time - TIME) + Number.MIN_VALUE;
	TIME = time;
	
	for(let widget of WIDGETS){
		if(widget.visible){
			widget.dt = dt;
			widget.mvel = {x:(widget.mpos.x - widget.mprev.x)/dt, y:(widget.mpos.y - widget.mprev.y)/dt};
			widget.mprev = widget.mpos;
			
			widget.ctx.clearRect(0, 0, widget.canvas.width, widget.canvas.height);
			widget.ctx.save();
			try {
				widget.repaint(time);
			} catch(e){
				console.error(e);
			}
			widget.ctx.restore();
		}
	}
	
	window.requestAnimationFrame(ANIMATE);
}
window.requestAnimationFrame(ANIMATE);
</script>

People _love_ water in video games. I can't count the number of times I've heard people talking about how realistic the water is in the latest and greatest game. I make no claims to be immune to it either as I've stopped to appreciate it's beauty in many a game. :)

![Water in Half Life 2](images/waves/hl2-water.jpg)
![Water in Subnautica](images/waves/subnautica-water.jpg)
{: style="text-align: center"}

Water in Half Life 2 and Subnautica.
{: style="text-align: center"}

Rendering and animating water are both pretty big topics, so this article is going to detail an algorithm for procedurally simulating interactive water waves using FFTs. Something like this!

<canvas id="wavies" style="border:solid 1px #0002;"></canvas>

<script>'use strict';
const AMPLITUDES = [
	0.0, 4.0, 6.4, 5.4,
	2.7, 0.6, 0.5, 0.6,
	1.0, 1.0, 0.7, 0.3,
	0.2, 0.5, 0.6, 0.2
];

new Widget("wavies", widget => {
	const {canvas, ctx} = widget;
	canvas.height = canvas.width/4;
	
	// Setup the waves with some initial frequencies in it.
	const spectra = lifft_complex_arr(64)
	for(let i = 0; i < AMPLITUDES.length; i++){
		const phase = 2*Math.PI*Math.random();
		[spectra.re[i], spectra.im[i]] = [AMPLITUDES[i]*Math.cos(phase), AMPLITUDES[i]*Math.sin(phase)];
	}
	let waves = lifft_inverse_complex(spectra);
	
	// Interact with the waves using the mouse.
	function interact_waves(mvel, waves){
		// Calculate mouse position in wave coordinates
		const scale = waves.n/canvas.width, mradius = 20;
		const mx = widget.mpos.x*scale;
		const my = canvas.height/2 - widget.mpos.y - waves.re[Math.floor(mx)]/scale;
		
		// The magnitude of the interaction. Linear fallof above the waterline, and exponential below.
		const mag = Math.min(Math.max(0, 1 - my/mradius), Math.exp(0.5*my/mradius));
		// Calculate the width of the interaction, widening it the deeper it goes.
		const width = Math.max(-1.5*my/mradius, 2);
		
		// Apply the interaction to the wave near the mouse.
		const x0 = Math.max(0, Math.floor(mx - width));
		const x1 = Math.min(Math.ceil(mx + width), waves.n - 1);
		for(let i = x0; i < x1; i++){
			// Use a gaussian curve as a strength to apply the interaction with.
			const dx = mx - i - 0.5, dx_w = dx/width;
			const gauss = -width*(1 + Math.exp(dx_w*dx_w));
			
			// Interpolate the wave velocity towards the mouse velocity.
			const damp = 1 - Math.exp(7e-2*mag/gauss);
			waves.im[i] -= ((dx*mvel.x + mvel.y)/waves.n + waves.im[i])*damp;
		}
	}
	
	// Update the waves
	function update_waves(waves, damping, dt){
		const n = waves.n;
		const spectra_x = lifft_complex_arr(n, waves.type);
		const spectra_y = lifft_forward_complex(waves);
		// The first value is the water height, force it to stay at 0.
		spectra_y.re[0] = spectra_y.im[0] = 0;
		spectra_y.re[n/2] = spectra_y.im[n/2] = 0;
		
		// Now iterate over the +/- frequency pairs and update their phases and AMPLITUDES.
		for(let i = 0; i <= n/2; i++){
			const phase = -dt*Math.sqrt(i)*Math.PI, mag = Math.exp(-dt*damping*i);
			const w = lifft_complex(mag*Math.cos(phase), mag*Math.sin(phase));
			
			const p = lifft_cmul(w, lifft_complex(spectra_y.re[i], spectra_y.im[i]));
			[spectra_x.re[i], spectra_x.im[i]] = [+p.im, -p.re];
			[spectra_y.re[i], spectra_y.im[i]] = [+p.re, +p.im];
			
			const j = -i & (n - 1);
			const q = lifft_cmul(w, lifft_complex(spectra_y.re[j], spectra_y.im[j]));
			[spectra_x.re[j], spectra_x.im[j]] = [-q.im, +q.re];
			[spectra_y.re[j], spectra_y.im[j]] = [+q.re, +q.im];
		}
		
		return [lifft_inverse_complex(spectra_x), lifft_inverse_complex(spectra_y)];
	}
	
	return function(time){
		const dt = widget.dt, mvel = widget.mvel;
		
		// Apply mouse interaction if necessary
		if(widget.mfocus && 0 < widget.mpos.x && widget.mpos.x < canvas.width) interact_waves(mvel, waves);
		
		// Update the waves.
		const [wave_x, wave_y] = update_waves(waves, 2e-2, dt);
		
		function max(a, b, k){
			// return Math.max(a, b);
			return Math.log(Math.exp(k*a) + Math.exp(k*b))/k;
		}
		
		const thresh = 1;
		for(let i = 0; i < wave_y.n; i++){
			const x_prev = wave_x.re[(i - 1)&(wave_x.n - 1)];
			const x_curr = wave_x.re[i];
			const x_next = wave_x.re[(i + 1)&(wave_x.n - 1)];
			const diff_max = Math.max(x_curr - x_next, x_prev - x_curr);
			const coef = 1/Math.max(1, diff_max);
			wave_y.re[i] *= coef;
			wave_y.im[i] *= coef;
		}
		
		waves = wave_y;
		
		const scale = canvas.width/(waves.n - 1);
		ctx.setTransform(scale, 0, 0, -scale, 0, canvas.height/2);
		ctx.lineCap = ctx.lineJoin = "round";
		
		ctx.beginPath();
		ctx.lineTo(0, -100);
		for(let i = 0; i < waves.n; i++){
			ctx.lineTo(i - 0.5*wave_x.re[i], wave_y.re[i]);
		}
		ctx.lineTo(canvas.width, -100);
		ctx.fillStyle = "#0CF";
		ctx.fill();

		// Draw mouse
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.fillStyle = "#FF0";
		ctx.strokeStyle = "#F80";
		ctx.lineWidth = 2;
		ctx.beginPath();
		ctx.arc(widget.mpos.x, widget.mpos.y, 20, 0, 2*Math.PI);
		ctx.fill();
		ctx.stroke();
		
		if(!widget.mfocus){
			ctx.setTransform(3, 0, 0, 3, canvas.width/2, canvas.height/3);
			ctx.fillStyle = "#0008";
			ctx.textAlign = "center";
			ctx.fillText("Use the Mouse to Interact", 0, 0);
		}
	}
})
</script>

Keep in mind that it's a just surface simulation, so horizontal mouse movements faster than the wave speed won't be very satisfying. ;) The algorithm itself extends to 3D easily enough, though I'll be doing it in 2D so it's easier to make quick visualizations.

## Lots of Water Algorithms

There's actually quite a lot of algorithms for simulating water. One of the simplest is to treat the water surface like a grid. For each cell you store the height and vertical velocity so you can simulate the motion. To step time forward you move the height with the velocity, then feed the height back into the velocity (when the water level is high it wants to accelerate back down, and vice versa). This makes the water bob up and down. To make the waves propagate you just need to average each cell with it's neighbors. This easy filtering method is pretty effective and very fast! To interact with the water, you just change the height or velocity values. Though delightfully simple to implement, it does have it's issues. For one, it's difficult to make framerate independent as the waves will move the same amount each step. It also doesn't _really_ move like water waves for a few reasons.

![Water ripples in Metroid Prime](images/waves/metroid-water.jpg)
{: style="text-align: center"}

Interactive water ripples in Metroid Prime
{: style="text-align: center"}

This is where fourier based methods come in using Fast Fourier Transforms, or FFTs, to simulate water. It gives you an intuitive way to perform much fancier filtering, and without a lot of extra cost! Instead of treating the grid like a bunch of locations that have waves in them somehow, the fourier transform lets you convert back and forth between a grid and waves. It's much easier to handle some of water's unique characteristics when dealing with waves. For example, unlike sound or light, water waves don't all move at the same speed. Long waves move faster than little waves giving water it's unique pulsing look as the different waves interact in complicated ways. Jump Trajectory has a nice overview video about how they [implemented the FFT based animation](https://www.youtube.com/watch?v=kGEqaX4Y4bQ) in Unity. It's an excellent video, but it's light on the details and assumes you already know how FFTs work. It also doesn't implement a simulation. That's what I'd like to fill in with this article.

![Ocean waves in Assasin's Creed](images/waves/acbf-water.jpg)
{: style="text-align: center"}

FFT based ocean waves in Assasin's Creed
{: style="text-align: center"}

At the extreme end of the spectrum, you can simulate the whole volume of water using fluid dynamics instead of just approximating it's surface. Waves can crest and fall over, they can splash, and the water can even pour across surfaces. Unsurprisingly, adding another dimension is _really_ expensive and simulating the whole volume usually isn't feasible except at low resolutions. While I've never implemented proper fluid dynamics myself, it really doesn't look all that hard. Ten Minute Physics recently posted a video on [implementing the FLIP algorithm](https://youtu.be/XmzBREkK8kY) in 2D. It looks surprisingly simple and fun! There's also a neat 2D fluid simulation library based on Box2D called [Liquid Fun](https://google.github.io/liquidfun/).

![Water simulated using the FLIP algorithm](images/waves/10minute-water.jpg)
{: style="text-align: center"}

A fluid simulationg using the FLIP algorithm from the 10 Minute Physics [blog](https://matthias-research.github.io/pages/tenMinutePhysics/index.html)
{: style="text-align: center"}

## A Quick Water Wave Primer

The first thing to know about waves (or almost any periodic motion really) is that it's just energy that's stuck in a loop. In the case of water waves, the energy bounces back between kinetic and potential energy. When the water is high, gravity pulls it down. It's momentum causes it to overshoot the equilibrium point, and it move down too far. Then the pressure of the water around it increases and pushes it back up. Then it overshoots again, and goes too high. Rinse and repeat endlessly. (pun intended)

![Wave cycle](images/waves/wave-cycle.svg)
{: style="text-align: center"}

A [phase plot](https://en.wikipedia.org/wiki/Phase_space#Phase_plot) of the water surface
{: style="text-align: center"}

# The Simplest Wave

Let's start with a simple wave model: a sine wave. (I swear there will be very little trigonometry involved in this article.) You'll probably remember that `y = sin(x)` gives you a nice wobbly line. If you want to animate it, you just need to change the phase using time: `y = sin(x - time)`. That produces a nice little animated wave that moves left to right like this one.

<canvas id="simple-wave" style="border:solid 1px #0002;"></canvas>

A simple animated wave
{: style="text-align: center"}

<script>'use strict';
new Widget("simple-wave", widget => {
	const {canvas, ctx} = widget;
	canvas.height = canvas.width/4;
	
	return function(t){
		const n = 20, scale = canvas.width/(n - 1);
		ctx.setTransform(scale, 0, 0, -scale, canvas.width/2, canvas.height/2);
		ctx.lineCap = ctx.lineJoin = "round";
		
		// Draw axis
		ctx.lineWidth = 1/scale;
		ctx.strokeStyle = "#888";
		ctx.beginPath();
		ctx.moveTo(-100, 0); ctx.lineTo(+100, 0);
		ctx.stroke();
		
		// Draw velocity
		ctx.strokeStyle = "#F002";
		ctx.beginPath();
		for(let i = -n/2; i <= n/2; i++) ctx.lineTo(i, 2*Math.sin(i/2 - t));
		ctx.stroke();
		
		// Draw spokes
		ctx.lineWidth = 1/scale;
		ctx.strokeStyle = "#0002";
		ctx.beginPath();
		for(let i = -n/2; i <= n/2; i++){
			ctx.moveTo(i, 0); ctx.lineTo(i, 2*Math.cos(i/2 - t));
		}
		ctx.stroke();
		
		// Draw wave
		ctx.lineWidth = 3/scale;
		ctx.strokeStyle = "#0CF";
		ctx.beginPath();
		for(let i = -n/2; i <= n/2; i++) ctx.lineTo(i, 2*Math.cos(i/2 - t));
		ctx.stroke();
		
		const y = 2*Math.cos(-t), vy = Math.sin(-t);
		ctx.fillStyle = ctx.strokeStyle = "#F00";
		ctx.lineWidth = 2/scale;
		
		// Draw dot
		ctx.beginPath();
		ctx.arc(0, y, 8/scale, 0, 2*Math.PI);
		ctx.fill();
		
		// Draw velocity line
		ctx.beginPath();
		ctx.moveTo(0, y); ctx.lineTo(0, y + vy);
		ctx.stroke();
		ctx.beginPath();
		ctx.moveTo(0, y + vy + Math.sign(vy)*0.3);
		ctx.lineTo(-0.15, y + vy);
		ctx.lineTo(+0.15, y + vy);
		ctx.fill();
	}
})
</script>

If the blue line is the water height, can you guess what the red line is? (Hint: watch the red arrow.) It's the water's vertical velocity. When the velocity is up it makes the height move up, and when the height is up it makes the velocity move down just like in the phase plot. Another way of looking at it is that the velocity wave pulls the height wave. If you swapped their positions they would pull wave to the left instead. The velocity will be important later when we talk about simulating waves, but for now let's take a shortcut and just animate the height.

# A Better Wave

Does the animated sine wave look like a water wave? Well... not really. First of all, if you compare it to the ocean waves in the Assasin's Creed screenshot above, it's the wrong shape. Those waves have pointy peaks and wide troughs. The reason for this is because real water waves don't just bob up and down, they _roll_ in roughly circlular path. This is called a [trochoidal](https://en.wikipedia.org/wiki/Trochoidal_wave) wave (sometimes called gerstner waves in computer graphics stuff). That's easy enough! Instead of just moving the vertexes up and down, we add something to move them back and forth too. While we are making changes, lets make add a wavelength and amplitude property. Now our height is:

`y = amplitude*sin(x/wavelength - time)`

(_Technically_ you need π represented in there for the wavelength, but if you don't care about using real units, then it doesn't matter.)

Each time a wave finishes a cycle, it moves forward by one wavelength. This is a mild problem because longer waves will move faster. If we want our waves to move at the same speed, then we need to slow down waves proportionally by their wavelength. Easy enough, just divide time to slow it down:

`y = amplitude*sin(x/wavelength - time/wavelength)`

Also for reasons we'll get into later when we talk about FFTs and complex numbers, let's swap that for a cosine instead. To make the trochoidal shape, we just need a matched pair of sines and cosines. The final wave code would look something like this:

<canvas id="better-wave" style="border:solid 1px #0002;"></canvas>
<div style="display:flex; align-items:center; column-gap:1em">
	<label>Example:</label>
	<select id="example-select">
		<option value="trochoidal">Trochoidal Wave</option>
		<option value="sine">Sine Wave</option>
	</select>
	<label>Wavelength:</label> <input type="range" style="width:120px" value="-0.5" min="-1.5" max="0.5" step="any" id="better-wave-wavelength"/>
	<label>Amplitude:</label>  <input type="range" style="width:120px" value=" 2.0" min=" 0.0" max="2.0" step="any" id="better-wave-amplitude" />
</div>

<textarea id="better-wave-code" rows="4" style="width:100%; font-size:125%" spellcheck="false"></textarea>
<pre id="better-wave-error" hidden="true"></pre>

Edit this code!
{: style="text-align: center"}

<script>'use strict';
new Widget("better-wave", widget => {
	const {canvas, ctx} = widget;
	canvas.height = canvas.width/4;
	
	const EXAMPLE = {
		trochoidal: (
			"let phase = x/wavelength - time/wavelength;\n" +
			"x_out = x - amplitude*sin(phase);\n" +
			"y_out = amplitude*cos(phase);\n"
		),
		sine: (
			"y_out = amplitude*cos(x/wavelength - time/wavelength);\n"
		),
	};
	
	function compile(code){
		return Function(
			"x", "time", "amplitude", "wavelength",
			`'use strict';
				const {sin, cos, sqrt} = Math;
				let x_out = x, y_out = 0;
				${code};
				return [x_out, y_out];
			`
		);
	}
	
	const code_area = document.getElementById("better-wave-code");
	code_area.value = EXAMPLE.trochoidal;
	
	let func = compile(code_area.value);
	code_area.oninput = (e => {
		const output = document.getElementById("better-wave-error");
		try {
			const f = compile(code_area.value);
			f(0, 0, 1, 1);
			func = f;
			output.hidden = true;
		} catch(err) {
			console.error(err);
			output.hidden = false;
			output.textContent = err;
		}
	})
	
	const example = document.getElementById("example-select");
	example.value = "trochoidal";
	example.oninput = (e => {
		code_area.value = EXAMPLE[example.value];
		code_area.oninput();
	})
	
	const wavelength_slider = document.getElementById("better-wave-wavelength");
	const amplitude_slider = document.getElementById("better-wave-amplitude");
	
	return function(t){
		const n = 20, scale = canvas.width/(n - 1);
		ctx.setTransform(scale, 0, 0, -scale, canvas.width/2, canvas.height/2);
		ctx.lineCap = ctx.lineJoin = "round";
		
		// Draw axis
		ctx.lineWidth = 1/scale;
		ctx.strokeStyle = "#888";
		ctx.beginPath();
		ctx.moveTo(-100, 0); ctx.lineTo(+100, 0);
		ctx.stroke();
		
		const wavelength = n*Math.exp(wavelength_slider.value)*0.5/Math.PI;
		const amplitude = 0 + amplitude_slider.value;
		const time = 4*t;
		
		// Draw spokes
		ctx.lineWidth = 1/scale;
		ctx.strokeStyle = "#0002";
		ctx.beginPath();
		for(let i = -n/2; i <= n/2; i++){
			const [x, y] = func(i, time, amplitude, wavelength);
			ctx.moveTo(i, 0); ctx.lineTo(x, y);
			
			const [x0, y0] = func(i, time, amplitude, wavelength);
			const [x1, y1] = func(i + 1, time, amplitude, wavelength);
		}
		ctx.stroke();
		
		// Draw wave
		ctx.lineWidth = 3/scale;
		ctx.strokeStyle = "#0CF";
		ctx.beginPath();
		for(let i = -n; i < n; i++){
			const [x, y] = func(i, time, amplitude, wavelength);
			ctx.lineTo(x, y);
		}
		ctx.stroke();
		
		const [x0, y0] = func(0, time, amplitude, wavelength);
		
		// Draw circle
		ctx.strokeStyle = "#F004";
		ctx.lineWidth = 1/scale;
		ctx.beginPath();
		ctx.arc(0, 0, amplitude, 0, 2*Math.PI);
		ctx.stroke();
		
		// Draw dot
		ctx.fillStyle = "#F00";
		ctx.beginPath();
		ctx.arc(x0, y0, 6/scale, 0, 2*Math.PI);
		ctx.fill();
	}
})
</script>

* What happens if you add time instead of subtracting it?
* What happens if you add the sine to the x coordinate instead of subtracting it?
* What happens if you swap the sine and cosine?
* Can you change the speed of the wave?

Lastly, if you didn't _immediately_ crank the wavelength and amplitude to their extremes, try it! If the ratio of the amplitude compared to the wavelength is too high, the trochoidal motion breaks down. A real wave would fall over and turn turbulent, turning it into a "breaking wave". We can sort of deal with this in our simple surface simulation, but you need real fluid dynamics to do it properly.

![example of a breaking wave](images/waves/wave-break.jpg)
{: style="text-align: center"}

By Steve Jurvetson from Menlo Park, USA - Step Into Liquid, CC BY 2.0, [link](https://commons.wikimedia.org/w/index.php?curid=3561785)
{: style="text-align: center"}


# Mixing Waves

This is starting to look much better, but it still looks very plain. Real wave crests are never quite quite the same size, and their spacing is irregular too. Does that mean you need to use random numbers? Nope! Real water waves are almost always a composite of many simpler waves just like ours above. Individually they move in extremely predictable ways, but when mixed together they gain a random quality.

Water waves have a trick that helps with this random appearance too. Unlike sound or light, water waves don't all move at the same speed. (Think about how weird that is for a second...) Specifically, a wave's speed is proportional to the square root of it's wavelength, so we just need to multiply that into our time factor like this:

```
y = amplitude*cos(x/wavelength - time*sqrt(wavelength)/wavelength)
```

Which simplifies to:

```
y = amplitude*cos(x/wavelength - time/sqrt(wavelength))
```

If we plot these waves separately, you can see that the blue wave has 4x the wavelength of the red wave, and moves 2x as fast. At least to my eyes, this just doesn't look right when you see them side by side.

<canvas id="two-waves" style="border:solid 1px #0002;"></canvas>

<script>'use strict';
new Widget("two-waves", widget => {
	const {canvas, ctx} = widget;
	canvas.height = canvas.width/4;
	
	return function(t){
		const n = 80, scale = canvas.width/(n - 1);
		ctx.setTransform(scale, 0, 0, -scale, canvas.width/2, canvas.height/2);
		ctx.lineCap = ctx.lineJoin = "round";
		
		// Draw long wave
		ctx.lineWidth = 3/scale;
		ctx.strokeStyle = "#0CF";
		ctx.beginPath();
		for(let i = -n; i < n; i++){
			const phase = i/8 - t*10/Math.sqrt(8);
			ctx.lineTo(i - 3*Math.sin(phase), 3*Math.cos(phase));
		}
		ctx.stroke();
		
		// Draw short wave
		ctx.lineWidth = 2/scale;
		ctx.strokeStyle = "#F00";
		ctx.beginPath();
		for(let i = -n; i < n; i++){
			const phase = i/2 - t*10/(2/Math.sqrt(2));
			ctx.lineTo(i - 0.5*Math.sin(phase), 0.5*Math.cos(phase));
		}
		ctx.stroke();
	}
})
</script>

Mixing waves is easy, you just add them together. Trochoidal waves have a vertical and horizontal component, so you just add them all up separately. (x, y, and z if doing 3D) Once mixed, we get the signature "pulsing" look of real waves.

<canvas id="mixed-waves" style="border:solid 1px #0002;"></canvas>

<textarea id="two-wave-code" rows="10" style="width:100%; font-size:125%" spellcheck="false">
x_out = x, y_out = 0;

let amp0 = 3.0, len0 = 8;
x_out -= amp0*sin(x/len0 - time/sqrt(len0));
y_out += amp0*cos(x/len0 - time/sqrt(len0));

let amp1 = 0.5, len1 = 2;
x_out -= amp1*sin(x/len1 - time/sqrt(len1));
y_out += amp1*cos(x/len1 - time/sqrt(len1));
</textarea>
<pre id="two-wave-error" hidden="true"></pre>

Edit this code!
{: style="text-align: center"}

<script>'use strict';
new Widget("mixed-waves", widget => {
	const {canvas, ctx} = widget;
	canvas.height = canvas.width/4;
	
	function compile(code){
		return Function(
			"x", "time",
			`'use strict';
				const {sin, cos, sqrt} = Math;
				let x_out = x, y_out = 0;
				${code};
				return [x_out, y_out];
			`
		);
	}

	const code_area = document.getElementById("two-wave-code");
	let func = compile(code_area.value);
	code_area.oninput = (e => {
		const output = document.getElementById("two-wave-error");
		try {
			const f = compile(code_area.value);
			f(0, 0);
			func = f;
			output.hidden = true;
		} catch(err) {
			console.error(err);
			output.hidden = false;
			output.textContent = err;
		}
	})

	return function(t){
		const n = 80, scale = canvas.width/(n - 1);
		ctx.setTransform(scale, 0, 0, -scale, canvas.width/2, canvas.height/2);
		ctx.lineCap = ctx.lineJoin = "round";
		
		// Draw long wave
		ctx.lineWidth = 3/scale;
		ctx.strokeStyle = "#0CF";
		ctx.beginPath();
		for(let i = -n; i < n; i++){
			let [x, y] = func(i, 10*t);
			ctx.lineTo(x, y);
		}
		ctx.stroke();
	}
})
</script>

* Try different wavelengths
* What happens if you pick wavelengths that are similar?
* Can you cause the wave to break by adding smaller waves that are fine independently?
* Try dividing time by wavelength like before instead of it's square root
* Try dividing time by a constant

If Mixing two waves looks so nice, you'd be correct to think that mixing more waves can look even better. The problem is how many do you need? For each additional wave you need to calculate a whole lot more sines and cosines. It gets even worse when you need to do this in 3D. CPUs and GPUs are insanely fast, but at some point brute forcing a problem won't work. Also, wasn't this supposed to be an article about interactive water simulation? How on earth do you interact with sine waves!?

## Mix _ALL_ the Waves!

Since you already know that this article is about using the FFT to simulate water, perhaps you won't be surprised when I reveal that the FFT is the magical solution that can calculate 10's of thousands of sines and cosines without the performance cost. Even better, you don't really even need to know much about trigonometry to use it. If you followed along with the scrolling sine waves above, you should be able to understand the rest of the article just fine.

# Complex Numbers

The FFT operates on complex numbers, so we should talk about the basics. Don't let the name fool you though, they're just like 2D vectors with many common properties. Addition works the same, and calculating their length or direction works the same way. Instead of x and y coordinates, they have "real" and "imaginary" parts that mean the same thing. When we work with the FFT to make a wave, it will give us the wavelength and we tell it the amplitude and phase shift of the wave using the length and the angle of a complex number we give back. It works like this:

<canvas id="complex-waves" style="border:solid 1px #0002;"></canvas>

The length of a complex number sets the amplitude of the wave, and the angle sets it's phase.
{: style="text-align: center"}

<script>"use strict";
new Widget("complex-waves", widget => {
	const {canvas, ctx} = widget;
	canvas.height = canvas.width/4
	
	return function(t){
		const scale = 0.5*canvas.height;
		ctx.setTransform(scale, 0, 0, -scale, canvas.width/2, scale);
		let {x, y} = (widget.mfocus ? widget.mlocal : {x: 0.5, y:-0.5});
		let mag = Math.hypot(x, y), phase = (2*Math.PI + Math.atan2(y, x))%(2*Math.PI);
		if(mag > 1){
			x /= mag;
			y /= mag;
			mag = 1;
		}
		
		// Draw axis
		ctx.lineWidth = 1/scale;
		ctx.strokeStyle = "#888"
		ctx.beginPath();
		ctx.moveTo(-10,  0); ctx.lineTo(10, 0);
		ctx.moveTo(  0, -1); ctx.lineTo( 0, 1);
		ctx.moveTo(-10, -mag); ctx.lineTo(10, -mag);
		ctx.moveTo(-10, +mag); ctx.lineTo(10, +mag);
		ctx.stroke();
		
		// Draw circle
		ctx.strokeStyle = "#CCC";
		ctx.beginPath();
		ctx.arc(0, 0, mag, 0, 2*Math.PI);
		ctx.stroke();
		
		// Draw wave
		ctx.lineWidth = 2/scale;
		ctx.strokeStyle = "#0CF"
		ctx.beginPath();
		// ctx.lineTo(0, 0); ctx.lineTo(1, 1);
		for(let x = -5; x < 5; x += 0.05) ctx.lineTo(x, mag*Math.sin(x*4 + phase));
		ctx.stroke();
		
		// Draw real/imag
		ctx.lineWidth = 4/scale;
		ctx.strokeStyle = "#F00"
		ctx.beginPath();
		ctx.moveTo(0, 0); ctx.lineTo(x, 0);
		ctx.stroke();
		ctx.strokeStyle = "#0F0"
		ctx.beginPath();
		ctx.moveTo(0, 0); ctx.lineTo(0, y);
		ctx.stroke();
		
		// Draw vector/angle
		ctx.lineWidth = 2/scale;
		ctx.strokeStyle = "#000"
		ctx.beginPath();
		ctx.moveTo(0, 0); ctx.lineTo(x, y);
		ctx.stroke();
		ctx.strokeStyle = "#00F";
		ctx.beginPath();
		ctx.arc(0, 0, mag*0.2	, 0, phase);
		ctx.stroke();
		
		ctx.strokeRect(-phase/4, -mag, Math.PI/2, 2*mag);
		// ctx.beginPath();
		// ctx.lineTo(0, mag);
		// ctx.lineTo((2*Math.PI - phase)/4, mag);
		// // ctx.lineTo((Math.PI - phase)/4, 0);
		// ctx.stroke();
		
		if(widget.mfocus){
			ctx.setTransform(1.5, 0, 0, 1.5, 0.05*canvas.width, 0.5*canvas.height);
			ctx.fillStyle = "#FFFC";
			ctx.fillRect(-10, -35, 160, 70);
			
			ctx.font = "medium monospace"
			ctx.textBaseline = "middle";
			ctx.fillStyle = "#F00";
			ctx.fillText(`     Real (x): ${x.toFixed(2)}`, 0, -24);
			ctx.fillStyle = "#0C0";
			ctx.fillText(`Imaginary (y): ${y.toFixed(2)}`, 0, -8);
			ctx.fillStyle = "#00F";
			ctx.fillText(`  Phase Angle: ${(phase*180/Math.PI).toFixed(0)}°`, 0, 8);
			ctx.fillStyle = "#000";
			ctx.fillText(`       Length: ${mag.toFixed(2)}`, 0, 24);
		} else {
			ctx.setTransform(2, 0, 0, 2, 0.5*canvas.width, 0.35*canvas.height);
			ctx.fillStyle = "#FFFD";
			ctx.fillRect(-1000, -1000, 2000, 2000);
			
			ctx.fillStyle = "#000";
			ctx.textBaseline = "middle";
			ctx.textAlign = "center";
			ctx.fillText("Use the Mouse to Interact", 0, 0);
		}
	}
})
</script>

The reason why the FFT uses complex numbers is because they are a shortcut for a bunch of trigonometry stuff. All you really need to know for this article is that multiplying two complex numbers adds their angles and multiplies their lengths. In other words, it does rotation and scaling in one step. The [underlying math](https://en.wikipedia.org/wiki/Complex_number#Multiplication_and_square) ends up being just a few regular additions and multiplications which is great for performance. Magic!

There's a lot more neat stuff to discover with complex numbers, like fractals or why they use _real_ and _imaginary_ instead of _x_ and _y_, but that's all you need to know for now.

# The FFT Algorithm

The most intuitive way to think of the Fast Fourier Transform, or FFT, is a way to break a sequence of numbers into an equivalent list of waves. If we ran our mixed wave from the last example through the FFT, it would separate it back into the red and blue waves. While you can add these waves back together yourself, it gets expensive very quickly since you have to compute a new list of sines and cosines for each wave. Instead you can undo the FFT, and mix those waves back together using the inverse FFT. If you were mixing them yourself, each additional wave would cost the same amount of performance, but when using the FFT each additional wave costs less than the one before it. Even better, because it uses complex number tricks, the FFT can skip nearly every single call to (mildly) expensive functions like `sin()` and `cos()`!

Time to get our feet wet! The 16 pairs of sliders on the left are the height and velocity at each grid point of the water. They come in pairs because they are actually complex numbers: height = real, velocity = imaginary. The 16 pairs on the right side are the amplitude and phase of the waves the water decomposes into. These are also complex numbers, but drawn using the length and angle since those are the wave properties we are interested in. Right away, you can see when the water surface looks like a sine wave, it decomposes into a single wave.

<canvas id="fft-io" style="border:solid 1px #0002;"></canvas>

Use the left mouse button to change values, or right mouse button to clear them.
{: style="text-align: center"}

<script>'use strict';
new Widget("fft-io", widget => {
	const {canvas, ctx} = widget;
	canvas.height = canvas.width/2;
	
	const N = 16;
	let input, output = lifft_complex_arr(N);
	function calc_input(){input = lifft_inverse_complex(output)};
	function calc_output(){output = lifft_forward_complex(input)};
	
	output.im[1] = -0.7;
	calc_input();
	
	function draw_bars(x, y, centered, f){
		let scale = 70, min, max;
		if(centered){
			ctx.setTransform(15, 0, 0, -scale, x*canvas.width, y*canvas.height);
			min = -1, max = 1;
		} else {
			ctx.setTransform(15, 0, 0, -2*scale, x*canvas.width, y*canvas.height + scale);
			scale *= 2, min = 0, max = 1;
		}
		
		ctx.fillStyle = "#DDD";
		for(let i = 0; i < N; i++) ctx.fillRect(i - N/2, min, 0.9, max - min);
		
		ctx.fillStyle = "#08C";
		for(let i = 0; i < N; i++){
			const value = Math.max(min, Math.min(f(i), max));
			ctx.fillRect(i - N/2, 0, 0.9, value);
		}
		
		ctx.strokeStyle = "#000";
		ctx.lineWidth = 1/scale;
		ctx.beginPath();
		ctx.lineTo(-N/2, 0);
		ctx.lineTo(+N/2, 0);
		ctx.stroke();
	}
	
	function mouse_input(min, f){
		const {x, y} = widget.mlocal;
		if(-N/2 < x && x < N/2 && min < y && y < 1){
			const mi = Math.floor(x + N/2);
			if(widget.mleft) f(mi, y);
			if(widget.mright) f(mi, 0);
		}
	}
	
	function get_abs(arr, i){return Math.hypot(arr.re[i], arr.im[i])}
	function set_abs(arr, i, v){
		const abs = get_abs(arr, i);
		if(abs > 0){
			const coef = v/(get_abs(arr, i) + Number.MIN_VALUE);
			arr.re[i] *= coef;
			arr.im[i] *= coef;
		} else {
			arr.re[i] = v;
		}
	}
	
	function get_arg(arr, i){return Math.atan2(arr.im[i], arr.re[i])/Math.PI}
	function set_arg(arr, i, v){
		const abs = get_abs(arr, i)
		arr.re[i] = abs*Math.cos(v*Math.PI);
		arr.im[i] = abs*Math.sin(v*Math.PI);
	}
	
	return function(t){
		draw_bars(0.2, 0.25, true, i => 4*input.re[i]);
		mouse_input(-1, (i, v) => {input.re[i] = v/4; calc_output()});
		draw_bars(0.2, 0.75, true, i => 4*input.im[i]);
		mouse_input(-1, (i, v) => {input.im[i] = v/4; calc_output()});
		
		draw_bars(0.8, 0.25, false, i => get_abs(output, i));
		mouse_input(0, (i, v) => {set_abs(output, i, v); calc_input()});
		draw_bars(0.8, 0.75, true, i => get_arg(output, i));
		mouse_input(-1, (i, v) => {set_arg(output, i, v); calc_input()});
		
		{
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			ctx.fillStyle = "#000";
			
			ctx.setTransform(1, 0, 0, 1, 0.5*canvas.width, 0.5*canvas.height);
			ctx.lineWidth = 1;
			ctx.strokeStyle = "#000";
			const w = 190, h = 100;
			ctx.strokeRect(-w/2, -h/2, w, h);
			
			const scale = 2;
			ctx.transform(scale, 0, 0, scale, 0, 0);
			ctx.strokeRect(0.5*(canvas.width - w), 0.5*(canvas.height - h), w, h);
			
			ctx.fillText("fft() -->", 0, -10);
			ctx.fillText("<-- inverse_fft()", 0, 10);
			
			ctx.setTransform(scale, 0, 0, scale, 0.2*canvas.width, 0.5*canvas.height);
			ctx.fillText("Water Surface (x)", 0, 0);
			
			ctx.setTransform(0, -scale, scale, 0, 0.02*canvas.width, 0.25*canvas.height);
			ctx.fillText("Height (y)", 0, 0);
			ctx.setTransform(0, -scale, scale, 0, 0.02*canvas.width, 0.75*canvas.height);
			ctx.fillText("Velocity (y)", 0, 0);
			
			ctx.setTransform(0, -scale, scale, 0, 0.98*canvas.width, 0.25*canvas.height);
			ctx.fillText("Amplitude", 0, 0);
			ctx.setTransform(0, -scale, scale, 0, 0.98*canvas.width, 0.75*canvas.height);
			ctx.fillText("Phase Angle", 0, 0);
			
			ctx.setTransform(scale, 0, 0, scale, 0.8*canvas.width, 0.5*canvas.height);
			ctx.fillText("Waves (frequencies)", 0, 0);
		}
		
		if(!widget.mfocus){
			ctx.setTransform(2, 0, 0, 2, 0.5*canvas.width, 0.5*canvas.height);
			ctx.fillStyle = "#FFFD";
			ctx.fillRect(-1000, -1000, 2000, 2000);
			
			ctx.fillStyle = "#000";
			ctx.textBaseline = "middle";
			ctx.textAlign = "center";
			ctx.fillText("Use the Mouse to Interact", 0, 0);
		}
	}
})
</script>

* What does the first wave value represent?
* What's the difference between the 2nd and last waves?
* How does the phase affect the 2nd and last wave differently?
* Which waves have long or short wavelengths?
* What's different about the 9th wave?
* Does changing a single water value change all waves?
* Does changing a single wave value change all of the water?
* The height and velocity always look similar. Do you remember [why](#the-simplest-wave)?

Now for some boring FFT details we need to know: When given a grid of _N_ water surface points, the FFT will split it into _N_ waves, and _N_ must be a power of two. (like 16, 256, 1024, etc) It also treats the input as a repeating sequence. This is _extremely_ handy if you want to make the results tileable, but mildly annoying if you don't. To avoid wrapping around you'll just need to save some space at the edges to clamp the height/velocity values to 0.

The wavelengths the FFT uses always follow a simple pattern: The first wave is just the average water height/velocity (think _wavelength = infinity_). Then next few waves will have wavelengths _N/1_, _N/2_, _N/3_ and so on. Eventually when you get to the middle, you'll have a wavelength of _N/(N/2)_, which simplifies to 2. Now the waves switch directions, and the wavelengths start getting longer until you get to the final wave with a wavelength of _N/1_ again. Put another way, the waves have wavelength _N/index_ in the first half and _N/(N&nbsp;-&nbsp;index)_ in the second half.

# Using the FFT on a 2D Grid for a 3D Game

To use the FFT for 3D water, you would apply it to the rows of the grid first, then apply it to the columns. (the order doesn't actually matter) It might seem weird to apply the FFT to the columns when they already contain wave information, but it works! The FFT is a [separable filter](https://en.wikipedia.org/wiki/Separable_filter) so you can take this nice computational shortcut. There's a few extra details you need to know for water in a 3D game, but there are plenty of resources for that once you know these basics.

# Animating Water with the FFT

With all that out of the way, let's animate some water with 64 waves and see what it looks like. Remember we have 3 wave parameters: wavelength, amplitude, and speed. We can pick the amplitudes ahead of time using the grey slider bars, the wavelenths define the speed `-time/sqrt(wavelength)`, and the inverse FFT defines the wavelengths we will use. Let's simplify things even further for now by ignoring the backwards moving waves (the second half of them), and since _N_ is a constant for all waves we can just use _1/i_ as the wavelength expression when calculating the speed. We can multiply the whole thing by a constant instead to control the time scale of all the waves leaving us with just `-time*time_scale*sqrt(i)` for the wave speed. The last little detail is that the grey bars will give us a complex number with a length controlled by the bar, and a random starting phase. (Waves kind of [explode](https://youtu.be/iWKFPTgkpXo?t=490) if their phases _all_ line up at the same time, and that doesn't really happen in nature.) All we need to do then is add our animated phase angle to the wave's complex number while keeping it's length. Remember that complex multiplication lets us add angles and multiply lengths. So if we multiply by `complex(cos(angle), sin(angle)`, then we get our angle with a length of 1.

<canvas id="fft1-waves" style="border:solid 1px #0002;"></canvas>

<textarea id="fft1-code" rows="7" style="width:100%; font-size:125%" spellcheck="false">
for(let i = 0; i < waves.n; i++){
  let phase = -5*time*sqrt(i)
  let phase_complex = complex(cos(phase), sin(phase));
  waves[i] = complex_multiply(waves[i], phase_complex);
}
water = inverse_fft(waves);
</textarea>
<pre id="fft1-error" hidden="true"></pre>

<script>'use strict';
const COMPLEX_ARRAY_PROXY = {
	get: (arr, idx) => arr[idx] || lifft_complex(arr.re[idx], arr.im[idx]),
	set: (arr, idx, val) => {
		[arr.re[idx], arr.im[idx]] = [val.re, val.im];
		return true;
	},
};

const SPECTRA = lifft_complex_arr(64), phases = [];
for(let i = 0; i < SPECTRA.n; i++){
	SPECTRA.re[i] = AMPLITUDES[i] || 0;
	phases[i] = 2*Math.PI*Math.random();
}

new Widget("fft1-waves", widget => {
	const {canvas, ctx} = widget;
	canvas.height = canvas.width/4;
	
	function compile(code){
		return Function(
			"time", "_spectra",
			`'use strict';
				const {cos, sin, sqrt} = Math;
				const complex = lifft_complex, complex_multiply = lifft_cmul, inverse_fft = lifft_inverse_complex;
				const waves = new Proxy(_spectra, COMPLEX_ARRAY_PROXY);
				let water = lifft_complex_arr(_spectra.n);
				${code};
				return water;
			`
		);
	}

	const code_area = document.getElementById("fft1-code");
	let func = compile(code_area.value);
	code_area.oninput = (e => {
		const output = document.getElementById("fft1-error");
		try {
			const f = compile(code_area.value);
			f(0, lifft_complex_arr(SPECTRA.n));
			func = f;
			output.hidden = true;
		} catch(err) {
			console.error(err);
			output.hidden = false;
			output.textContent = err;
		}
	});
	
	return function(t){
		// Init spectra with SPECTRA*phases.
		const spectra = lifft_complex_arr(SPECTRA.n);
		for(let i = 0; i < SPECTRA.n; i++){
			const w = lifft_complex(Math.cos(phases[i]), Math.sin(phases[i]));
			const p = lifft_cmul(w, lifft_complex(SPECTRA.re[i], SPECTRA.im[i]));
			[spectra.re[i], spectra.im[i]] = [p.re, p.im];
		}
		
		const water = func(t, spectra);
		
		const scale = canvas.width/(water.n - 1);
		
		ctx.setTransform(canvas.width/water.n, 0, 0, -5, 0, canvas.height);
		const {x:mx, y:my} = widget.mlocal;
		const mi = Math.floor(Math.max(0, Math.min(mx, SPECTRA.n - 1)));
		const mi_signed = (mi ^ SPECTRA.n/2) - SPECTRA.n/2;
		
		if(widget.mleft) SPECTRA.re[mi] = my/(mi == 0 ? 1 : Math.abs(mi_signed));
		if(widget.mright) SPECTRA.re[mi] = 0;
		
		for(let i = 0; i < SPECTRA.n; i++){
			ctx.fillStyle = i == mi ? "#0F04" : "#0002";
			const weight = i == 0 ? 1 : (SPECTRA.n/2 - Math.abs(SPECTRA.n/2 - i));
			ctx.fillRect(i, 0, 0.9, weight*SPECTRA.re[i]);
		}
		
		ctx.setTransform(scale, 0, 0, -scale, 0, canvas.height/2);
		ctx.lineCap = ctx.lineJoin = "round";
		
		ctx.lineWidth = 3/scale;
		ctx.strokeStyle = "#0CF";
		ctx.beginPath();
		for(let i = 0; i < water.n; i++) ctx.lineTo(i - water.im[i], water.re[i]);
		ctx.stroke();
		
		ctx.fillStyle = "#000D";
		ctx.textAlign = "center";
		ctx.setTransform(2, 0, 0, 2, 0.5*canvas.width, 0.25*canvas.height);
		ctx.fillText("Left drag to set spectrum. Right drag to clear.", 0, 0);
		
		if(widget.mfocus){
			ctx.setTransform(2, 0, 0, 2, 0.5*canvas.width, 0.75*canvas.height);
			ctx.fillText(`Wavelength: ${(1/mi_signed).toPrecision(2)}, Amplitude: ${SPECTRA.re[mi].toPrecision(1)}`, 0, 0);
		}
	}
})
</script>

Edit this code!
{: style="text-align: center"}

* Experiment with the wave speeds.
* Can you make the waves all move the same speed?
* Can you make the waves move to the left?
* What happens if you negate the sin() or cos()? Do you know why?
* What happens if you replace the sin() or cos() with zero?
* Does the animation work if you add backwards waves? (The bars on the right half)

This is looking pretty good. The peak heights and spacing are all different and always changing. It looks random yet it's _entirely_ predictable from the initial state set by the gray bars. We can easily predict what the water will look like at any time in the future or past with just 5 lines of code! To draw it, the "real" parts of the numbers are the sum of the cosines, and the "imaginary" parts are the sum of the cosines. These substite right into the old drawing code you wrote before like this:

```
x_out[i] = i - water[i].imaginary;
y_out[i] = water[i].real
```

Now, since we ignored handling the wavelengths of the backwards waves (the ones in the second half), so it's not suprising that they make things glitchy. That's easy enough to fix though, we can just process the waves in forwards/backwards pairs that share a wavelength. The other issue is that we are sort of abusing the water's imaginary number component. It's _supposed_ to be the velocity of the water's surface, and it's only a coincedence that it's the same value we needed for the trochoidal motion. For backwards moving waves it goes negative and turns the trochoidal shape upside down. Drat! The fix for that is a bit more annoying as we need to make a second set of waves for the x motion. The forward moving waves need to be 90° behind, and the backwards moving waves 90° ahead. We can just swap some coordinates to make the right angle changes. Now we have two arrays of complex numbers for the x and y positions of the water, and use the "real" values of each to draw it.

<canvas id="fft2-waves" style="border:solid 1px #0002;"></canvas>

<textarea id="fft2-code" rows="16" style="width:100%; font-size:125%" spellcheck="false">
for(let i = 0; i <= waves.n/2; i++){
  let phase = -5*time*sqrt(i);
  let phase_complex = complex(cos(phase), sin(phase));
  
  let p = complex_multiply(waves[i], phase_complex);
  waves_x[i] = complex(-p.im, p.re);
  waves_y[i] = p;
  
  let j = (waves.n - i) % waves.n;
  let q = complex_multiply(waves[j], phase_complex);
  waves_x[j] = complex(q.im, -q.re);
  waves_y[j] = q;
}
water_x = inverse_fft(waves_x);
water_y = inverse_fft(waves_y);
</textarea>
<pre id="fft2-error" hidden="true"></pre>

Edit this code!
{: style="text-align: center"}

<script>'use strict';
new Widget("fft2-waves", widget => {
	const {canvas, ctx} = widget;
	canvas.height = canvas.width/4;
	
	function compile(code){
		return Function(
			"time", "_spectra",
			`'use strict';
				const {cos, sin, sqrt} = Math;
				const complex = lifft_complex, complex_multiply = lifft_cmul, inverse_fft = lifft_inverse_complex;
				const waves = new Proxy(_spectra, COMPLEX_ARRAY_PROXY);
				const waves_x = new Proxy(lifft_complex_arr(_spectra.n), COMPLEX_ARRAY_PROXY);
				const waves_y = new Proxy(lifft_complex_arr(_spectra.n), COMPLEX_ARRAY_PROXY);
				let water_x = lifft_complex_arr(_spectra.n);
				let water_y = lifft_complex_arr(_spectra.n);
				${code};
				return [water_x, water_y];
			`
		);
	}

	const code_area = document.getElementById("fft2-code");
	let func = compile(code_area.value);
	code_area.oninput = (e => {
		const output = document.getElementById("fft2-error");
		try {
			const f = compile(code_area.value);
			f(0, lifft_complex_arr(SPECTRA.n));
			func = f;
			output.hidden = true;
		} catch(err) {
			console.error(err);
			output.hidden = false;
			output.textContent = err;
		}
	})
	
	return function(t){
		// Init spectra with SPECTRA*phases.
		const spectra = lifft_complex_arr(SPECTRA.n);
		for(let i = 0; i < SPECTRA.n; i++){
			const w = lifft_complex(Math.cos(phases[i]), Math.sin(phases[i]));
			const p = lifft_cmul(w, lifft_complex(SPECTRA.re[i], SPECTRA.im[i]));
			const j = -i & (SPECTRA.n - 1);
			[spectra.re[j], spectra.im[j]] = [p.re, p.im];
		}
		
		const scale = canvas.width/(spectra.n - 1);
		const [water_x, water_y] = func(t, spectra);
		
		ctx.setTransform(canvas.width/spectra.n, 0, 0, -5, 0, canvas.height);
		const {x:mx, y:my} = widget.mlocal;
		const mi = Math.floor(Math.max(0, Math.min(mx, SPECTRA.n - 1)));
		const mi_signed = (mi ^ SPECTRA.n/2) - SPECTRA.n/2;
		
		if(widget.mleft) SPECTRA.re[-mi & (SPECTRA.n - 1)] = my/(mi == 0 ? 1 : Math.abs(mi_signed));
		if(widget.mright) SPECTRA.re[-mi & (SPECTRA.n - 1)] = 0;
		
		for(let i = 0; i < SPECTRA.n; i++){
			const j = -i & (SPECTRA.n - 1);
			ctx.fillStyle = j == mi ? "#0F04" : "#0002";
			const weight = i == 0 ? 1 : (SPECTRA.n/2 - Math.abs(SPECTRA.n/2 - i));
			ctx.fillRect(j, 0, 0.9, weight*SPECTRA.re[i]);
		}
		
		ctx.setTransform(scale, 0, 0, -scale, 0, canvas.height/2);
		ctx.lineCap = ctx.lineJoin = "round";
		
		ctx.lineWidth = 3/scale;
		ctx.strokeStyle = "#0CF";
		ctx.beginPath();
		for(let i = 0; i < spectra.n; i++) ctx.lineTo(i + water_x.re[i], water_y.re[i]);
		ctx.stroke();
		
		ctx.fillStyle = "#0008";
		ctx.textAlign = "center";
		ctx.setTransform(2, 0, 0, 2, 0.5*canvas.width, 0.25*canvas.height);
		ctx.fillText("Left drag to set spectrum. Right drag to clear.", 0, 0);
		
		if(widget.mfocus){
			ctx.setTransform(2, 0, 0, 2, 0.5*canvas.width, 0.75*canvas.height);
			ctx.fillText(`Wavelength: ${(1/mi_signed).toPrecision(2)}, Amplitude: ${SPECTRA.re[mi].toPrecision(1)}`, 0, 0);
		}
	}
})
</script>

* Try adding both forwards and backwards moving waves.
* Try experimenting with the `waves_x` values to see how it changes the wave shapes.

This is quite a bit more complicated than the last code snippet, but now we can animate basically any sort of surface wave interaction.

## Water Simulation

This article promised water simulation, but everything has been only about animation so far. Don't ask for your money back just yet! We only need a few extra changes to turn our animation into a full blown simulation. It's easy to understand how to interact with the water as a grid. You change the position or velocity of certain cells to match objects interacting with the surface. It's not obvious how to interact with a list of waves though. The great part about working with fourier transforms is that you can use both representations and switch between them quickly. We've only been using the inverse FFT to switch in one direction, but we can go both ways.

We'll keep the water interaction simple. If the mouse is down, push down the water height of the cells near the mouse. Then we convert the water surface to waves using the FFT and animate them similar to before, but with a couple differences. First, since we aren't animating the waves from an initial state, we need to change the time to advance from the previous frame instead (_delta_time_). Second, to make the waves lose energy over time, we apply some damping by multiplying the phase by an exponential term to make it's length a little less than 1.0. Shorter waves lose energy faster, so I multiplied that in too. It looks ok, but I have no idea if that particular math is physically accurate.

<canvas id="fft3-waves" style="border:solid 1px #0002;"></canvas>

<textarea id="fft3-code" rows="30" style="width:100%; font-size:125%" spellcheck="false">
waves_y = fft(water_y);
waves_y[0] = complex(0, 0);

for(let i = 0; i <= waves_y.n/2; i++){
  let phase = -5*delta_time*sqrt(i);
  let phase_complex = complex(cos(phase), sin(phase));
  
  let damping = exp(-0.1*delta_time*i);
  phase_complex.re *= damping;
  phase_complex.im *= damping;
  
  let p = complex_multiply(waves_y[i], phase_complex);
  waves_x[i] = complex(-p.im, p.re);
  waves_y[i] = p;
  
  let j = (waves_y.n - i) % waves_y.n;
  let q = complex_multiply(waves_y[j], phase_complex);
  waves_x[j] = complex(q.im, -q.re);
  waves_y[j] = q;
}

water_x = inverse_fft(waves_x);
water_y = inverse_fft(waves_y);

if(click_x){
  for(let i = -1; i < 1; i++){
    water_y.re[i + Math.floor(click_x)] -= 30*delta_time;
  }
}
</textarea>
<pre id="fft3-error" hidden="true"></pre>

Edit this code!
{: style="text-align: center"}

<script>'use strict';
new Widget("fft3-waves", widget => {
	const {canvas, ctx} = widget;
	canvas.height = canvas.width/4;
	
	function compile(code){
		return Function(
			"delta_time", "water_y", "click_x",
			`'use strict';
				const {cos, sin, sqrt, exp, min, max} = Math;
				const complex = lifft_complex, complex_multiply = lifft_cmul;
				const inverse_fft = (arr => new Proxy(lifft_inverse_complex(arr), COMPLEX_ARRAY_PROXY));
				const fft = (arr => new Proxy(lifft_forward_complex(arr), COMPLEX_ARRAY_PROXY));
				const waves_x = new Proxy(lifft_complex_arr(water_y.n), COMPLEX_ARRAY_PROXY);
				let waves_y = new Proxy(lifft_complex_arr(water_y.n), COMPLEX_ARRAY_PROXY);
				let water_x = new Proxy(lifft_complex_arr(water_y.n), COMPLEX_ARRAY_PROXY);
				${code};
				return [water_x, water_y];
			`
		);
	}

	const code_area = document.getElementById("fft3-code");
	let func = compile(code_area.value);
	code_area.oninput = (e => {
		const output = document.getElementById("fft3-error");
		try {
			const f = compile(code_area.value);
			f(0, lifft_complex_arr(SPECTRA.n));
			func = f;
			output.hidden = true;
		} catch(err) {
			console.error(err);
			output.hidden = false;
			output.textContent = err;
		}
	})
	
	let water_y = lifft_complex_arr(SPECTRA.n);
	return function(t){
		const delta_time = widget.dt;
		
		const scale = canvas.width/(water_y.n - 1);
		ctx.setTransform(scale, 0, 0, -scale, 0, canvas.height/2);
		const click_x = (widget.mleft && widget.mlocal.x);
		
		let water_x;
		[water_x, water_y] = func(delta_time, water_y, click_x);
		
		const waves_y = lifft_forward_complex(water_y);
		ctx.setTransform(canvas.width/waves_y.n, 0, 0, -5, 0, canvas.height);
		for(let i = 0; i < waves_y.n; i++){
			ctx.fillStyle = "#0002";
			const weight = i == 0 ? 1 : (waves_y.n/2 - Math.abs(waves_y.n/2 - i));
			ctx.fillRect(i, 0, 0.9, weight*Math.hypot(waves_y.re[i], waves_y.im[i]));
		}
		
		ctx.setTransform(scale, 0, 0, -scale, 0, canvas.height/2);
		ctx.lineCap = ctx.lineJoin = "round";
		
		ctx.lineWidth = 3/scale;
		ctx.strokeStyle = "#0CF";
		ctx.beginPath();
		for(let i = 0; i < water_y.n; i++) ctx.lineTo(i + water_x.re[i], water_y.re[i]);
		ctx.stroke();
		
		ctx.fillStyle = "#0008";
		ctx.textAlign = "center";
		ctx.setTransform(2, 0, 0, 2, 0.5*canvas.width, 0.25*canvas.height);
		ctx.fillText("Click to add splashes.", 0, 0);
	}
})
</script>

* Can you make a better interaction than pushing the height down in a square?
* I set the first wave to 0. What happens if you remove that? Do you know why?
* Try clicking and dragging the mouse to make a big wave.

The code snippet has gotten pretty long at this point, but it didn't take much more to turn our animation into a simulation. The last problem to solve is that there is nothing to stop breaking waves from happening. Before we were animating waves that were in equilibrium, as if they were blown along by the wind perhaps. We could simply hand tweak the wave amplitudes to prevent breaking waves. Now the waves are set by the simulation state. The easiest solution is to scale down the x component of the trochoidal motion, or remove it altogether. Otherwise we'll have to detect breaking crests where they happen. Scan through the water grid and look at the x values to see if the mesh vertexes will move beyond their neighbors. If they do, then scale down their height and velocity to decrease the energy at their location. You could use this information to add splashes or foam to the wave crest when drawing too I suppose. The code for that looks like the following. You can paste it into the last example after the `if(click_x){}` block if you want to try it out.

```js
let n = water_y.n;
for(let i = 0; i < n; i++){
  let x_prev = water_x[(i - 1 + n)%n].re;
  let x_curr = water_x[i].re;
  let x_next = water_x[(i + 1)%n].re;
  let xdiff_max = max(x_curr - x_next, x_prev - x_curr);
  if(xdiff_max > 1){
    let coef = complex(1/xdiff_max, 0);
    water_y[i] = complex_multiply(water_y[i], coef);
  }
}
```

## Closing thoughts:

Hopefully this article has given you a bit of intuition for the FFT, and a better understanding of the underlying math of waves. I put a lot of hours into making all the interactive content for this article, but I'm a complete Javascript dunderhead. If you know how to improve on any of this please let me know!

The keen eyed DSP die hards among you might have noticed that updating the waves is a convolution. The filter impulse is the same length as the FFT window, so it wouldn't be practical for an animation, but for a small time step you could approximate it with a truncated FIR filter. This would definitely work, and I'd be interested to try it out someday to see if the accuracy and performance tradeoffs are worthwhile.

If you made it to the end, then I'm sorry for this, but it simply had to be done: Thanks for taking the plunge with me as we dove into this algorithm. Now it's time for one final wave... goodbye.
