A few years ago there was a startup called Apportable. They made tools for cross-compiling native iOS software to Android, and it worked pretty good. This was especially true for games, and so it was in their best interest to keep iOS gamedev tools healthy. After Riq the original Cocos2D developer moved on to the Cocos2D-X branch, Apportable started funding some of the more active community members and related project such as SpriteBuilder (a Cocos2D editor), and Chipmunk2D (my 2D physics library) to step in and maintain the project.

![SpriteBuilder](/images/DriftGraphicsAbstraction/SpriteBuilderLogo.png)

Our efforts got rolled together under the banner of Cocos2D-SpriteBuilder. One of the big projects I wanted to tackle was to move to using command buffers and executing them on a dedicated rendering thread. I was told a few times that attempting to thread Cocos2D was pointless and would provide little to no performance benefit. You see Cocos2D was scene graph based, and rendering meant traversing the graph and calling the draw methods. These would modify the OpenGL state and make draw calls. Serial traversal and global graphics state will probably make some readers cringe in 2020, but to be fair Cocos2D was created by one guy in his spare time for the original iPhone running on a single core CPU + OpenGLES 1.x. Unfortunately, by 2015 the dual core iPad 2 was the minimum spec many devs were targeting, and Cocos2D didn't really have a way of taking advantage of that second CPU core.

So I buckled down and rewrote _all_ of the rendering code to wrap it up into a command buffer with explicit graphics state objects. That would then get passed to a dedicated rendering thread for execution. Additionally, I was able to implement automatic batching and culling based on the simplified state tracking. The benefit was understandably huge. :D Here's an early video of a demo we made for GDC that year. This ran at a smooth 60 Hz on a (at the time) "old and slow" iPad 2 with hundreds of sprites in the scene all backed by rigid bodies, colliders, and a bunch of other eye candy. I was quite pleased to achieve this sort of performance with minimal changes to the external API. :) Eventually I even made an optional Metal based renderer too.

<iframe width="560" height="315" src="https://www.youtube.com/embed/eJsnCOkG8qs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Unfortunately the success was short lived. Shortly after GDC that year, most of Apportable's funding went away and unfortunately the SpriteBuilder collapsed shortly after due to internal politics about how we should continue. Oh well. I guess nothing lasts forever, except for chasing the dream of making the "perfect" 2D renderer.
